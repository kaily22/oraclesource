--PL/SQL
--화면 출력 
SET SERVEROUTPUT ON; 
BEGIN
  DBMS_OUTPUT.PUT_LINE('HELLO, PL/SQL');
END;
/

-- 변수 사용
DECLARE  
   V_EMPNO NUMBER(4) := 7788;
   V_ENAME VARCHAR2(10);
BEGIN 
  V_ENAME := 'SCOTT';
  DBMS_OUTPUT.PUT_LINE('V_EMPNO : ' || V_EMPNO);
  DBMS_OUTPUT.PUT_LINE('V_EMPNO : ' || V_ENAME);

END;
/

--상수 선언하기
DECLARE
  V_TAX CONSTANT NUMBER(1) :=3;
BEGIN 
   DBMS_OUTPUT.PUT_LINE('V_TAX : ' || V_TAX);
END;
/


--변수의 기본값 지정
DECLARE  
   V_DEPTNO NUMBER(4) DEFAULT 10;
BEGIN 
  DBMS_OUTPUT.PUT_LINE('V_DEPTNO : '|| V_DEPTNO);
END;
/

--널 값 막기
DECLARE  
   V_DEPTNO NUMBER(4) NOT NULL DEFAULT 10;
BEGIN 
  DBMS_OUTPUT.PUT_LINE('V_DEPTNO : '|| V_DEPTNO);
END;
/
--SCOTT 실행
SET SERVEROUTPUT ON;
DECLARE  
 V_DEPT_ROW DEPT%ROWTYPE;
BEGIN 
  SELECT DEPTNO, DANME, LOC INTO V_DEPT_ROW
  FROM DEPT
  WHERE DEPTNO = 40;
  DBMS_OUTPUT.PUT_LINE('DEPTNO : '|| V_DEPT_ROW.DEPTNO);
  DBMS_OUTPUT.PUT_LINE('DAME : '|| V_DEPT_ROW.DAME);
  DBMS_OUTPUT.PUT_LINE('LOC : '|| V_DEPT_ROW.LOC);
END;
/


DECLARE 
  V_NUMBER NUMBER(8) := 13;
BEGIN 
  IF MOD(V_NUMBER,2) = 1 THEN
     DBMS_OUTPUT.PUT_LINE('홀수');
     END IF; 
END;
/

DECLARE 
  V_NUMBER NUMBER(8) := 12;
BEGIN 
  IF MOD(V_NUMBER,2) = 1 THEN
     DBMS_OUTPUT.PUT_LINE('홀수');
  ELSIF MOD(V_NUMBER,2) =0 THEN
     DBMS_OUTPUT.PUT_LINE('짝수'); 
  END IF;
END;
/

DECLARE 
  V_NUMBER NUMBER := 87;
BEGIN 
  IF V_NUMBER >= 90 THEN
    DBMS_OUTPUT.PUT_LINE('A 학점');
   ELSIF V_NUMBER >=80 THEN
      DBMS_OUTPUT.PUT_LINE('B 학점');
   ELSIF V_NUMBER >=70 THEN
      DBMS_OUTPUT.PUT_LINE('C 학점');
    ELSIF V_NUMBER >=60 THEN
       DBMS_OUTPUT.PUT_LINE('D 학점');
  ELSE 
     DBMS_OUTPUT.PUT_LINE('F 학점');
     END IF;
END;
/
--CASE 조건문
DECLARE 
  V_NUMBER NUMBER := 87;
BEGIN 
   CASE TRUNC(V_NUMBER/10) 
   WHEN 10 THEN DBMS_OUTPUT.PUT_LINE('A 학점');
   WHEN 9  THEN DBMS_OUTPUT.PUT_LINE('B 학점');
   WHEN 8 THEN DBMS_OUTPUT.PUT_LINE('C 학점');
   WHEN 7 THEN DBMS_OUTPUT.PUT_LINE('D 학점'); 
       DBMS_OUTPUT.PUT_LINE('F 학점');
 END CASE;
END;
/
--CASE 조건문
DECLARE 
  V_NUMBER NUMBER := 87;
BEGIN 
   CASE TRUNC(V_NUMBER/10) 
   WHEN 10 THEN DBMS_OUTPUT.PUT_LINE('A 학점');
   WHEN 9  THEN DBMS_OUTPUT.PUT_LINE('B 학점');
   WHEN 8 THEN DBMS_OUTPUT.PUT_LINE('C 학점');
   WHEN 7 THEN DBMS_OUTPUT.PUT_LINE('D 학점'); 
       DBMS_OUTPUT.PUT_LINE('F 학점');
 END CASE;
END;
/

--반복문
DECLARE 
 V_NUM NUMBER := 0;
BEGIN 
  FOR i IN 0..4 LOOP
   CONTINUE WHEN MOD(i,2) = 1;
    DBMS_OUTPUT.PUT_LINE('현재 i : '||i);
  END LOOP;
END;
/

--반복문
DECLARE 
 V_NUM NUMBER := 0;
BEGIN 
  FOR i IN 0..4 LOOP
    DBMS_OUTPUT.PUT_LINE('현재 i : '||i);
  END LOOP;
END;
/

--반복문
DECLARE 
 V_NUM NUMBER := 0;
BEGIN 
  FOR i IN 0..4 LOOP
    DBMS_OUTPUT.PUT_LINE('현재 i : '||i);
  END LOOP;
END;
/

DECLARE 
 V_SUM NUMBER := 0;
BEGIN 
  FOR i IN 1..100 LOOP
   V_SUM := V_SUM+i;
   END LOOP;
   DMBS_OUTPUT.PUT_LINE('현재 V_SUM :' || V_SUM);
END;
/

DECLARE
 V_NUM NUMBER := 0;
BEGIN 
  FOR i IN 0..4 LOOP
  CONTINUE WHEN MOD(i,2) = 1;
    DBMS_OUTPUT.PUT_LINE('현재 i : '||i);
  END LOOP;
END;
/

--홀수만 출력
DECLARE
 V_NUM NUMBER := 0;
BEGIN 
  FOR i IN 0..4 LOOP
  CONTINUE WHEN MOD(i,2) = 0;
    DBMS_OUTPUT.PUT_LINE('현재 i : '||i);
  END LOOP;
END;
/

--레코드 : DB 하나의 행위, 자료형이 다른 여러 데이터를 저장
DECLARE
  TYPE REC_DEPT IS RECORD( 
    DEPTNO NUMBER(2) NOT NULL:= 99,
    DNAME VARCHAR2(12),
    LOC VARCHAR(20));
    DEPT_rec REC_DEPT;
BEGIN
   --DEPT_rec.DEPTNO := 55;
   DEPT_rec.DNAME := 'DATABASE';
   DEPT_rec.LOC := 'SEOUL';
   DBMS_OUTPUT.PUT_LINE('DEPTNO : ' ||DEPT_rec.DEPTNO);
   DBMS_OUTPUT.PUT_LINE('DNAME : ' ||DEPT_rec.DNAME);
   DBMS_OUTPUT.PUT_LINE('LOC : ' ||DEPT_rec.LOC);
   
END;
/

--레코드를 사용한 INSERT
CREATE TABLE DEPT_RECORD AS SELECT * FROM SCOTT.DEPT;

SELECT * FROM DEPT_RECORD;


DECLARE
  TYPE REC_DEPT IS RECORD( 
    DEPTNO NUMBER(2) NOT NULL:= 99,
    DNAME VARCHAR2(12),
    LOC VARCHAR(20));
    DEPT_rec REC_DEPT;
BEGIN
   DEPT_rec.DEPTNO := 55;
   DEPT_rec.DNAME := 'DATABASE';
   DEPT_rec.LOC := 'SEOUL';
INSERT INTO DEPT_RECORD
VALUES DEPT_rec;
END;
/


--레코드를 사용한 UPDATE
DECLARE
  TYPE REC_DEPT IS RECORD( 
    DEPTNO NUMBER(2) NOT NULL:= 99,
    DNAME VARCHAR2(12),
    LOC VARCHAR(20));
    DEPT_rec REC_DEPT;
BEGIN
   DEPT_rec.DEPTNO := 60;
   DEPT_rec.DNAME := 'SERVER';
   DEPT_rec.LOC := 'BUSAN';
UPDATE DEPT_RECORD
SET ROW = DEPT_rec
WHERE DEPTNO = 55;
END;
/
SELECT * FROM DEPT_RECORD;



--커서 : SELECT 문 또는 데이터 조작어 같은 SQL문 실행 시 해당 SQL문을 처리하는 정보를 
--저장한 메모리 공간을 가리키는 포인터

--명시적 커서/묵시적 커서

DECLARE
  V_DEPT_ROW SCOTT.DEPT%ROWTYPE;
  
  --명시적 커서 선언
  CURSOR c1 IS
     SELECT DEPTNO, DNAME, LOC
     FROM SCOTT.DEPT
     WHERE DEPTNO = 40;
BEGIN
  --커서 열기
  OPEN c1;
  
  --커서를 통해 읽어온 데이터 사용
  FETCH c1 INTO v_dept_row;
   DBMS_OUTPUT.PUT_LINE('DEPTNO : ' ||V_DEPT_ROW.DEPTNO);
   DBMS_OUTPUT.PUT_LINE('DNAME : ' ||V_DEPT_ROW.DNAME);
   DBMS_OUTPUT.PUT_LINE('LOC : ' ||V_DEPT_ROW.LOC);
  
  --커서 닫기
  CLOSE c1;
END;



DECLARE
  V_DEPT_ROW SCOTT.DEPT%ROWTYPE;
  
  --명시적 커서 선언
  CURSOR c1 (P_DEPTNO SCOTT.DEPT.DEPTNO%TYPE) IS
     SELECT DEPTNO, DNAME, LOC
     FROM SCOTT.DEPT
     WHERE DEPTNO = P_DEPTNO;
BEGIN
  --커서 열기
  OPEN c1(10);
  LOOP
  --커서를 통해 읽어온 데이터 사용
  FETCH c1 INTO v_dept_row;
  
  EXIT WHEN C1%NOTFOUND;
  
  
   DBMS_OUTPUT.PUT_LINE('DEPTNO : ' ||V_DEPT_ROW.DEPTNO);
   DBMS_OUTPUT.PUT_LINE('DNAME : ' ||V_DEPT_ROW.DNAME);
   DBMS_OUTPUT.PUT_LINE('LOC : ' ||V_DEPT_ROW.LOC);
  END LOOP;
  --커서 닫기
  CLOSE c1;
END;

--FOR문으로 바꾸기
DECLARE
  CURSOR c1 IS
     SELECT DEPTNO, DNAME, LOC
     FROM SCOTT.DEPT;
BEGIN
  FOR c1_rec IN c1 LOOP
   DBMS_OUTPUT.PUT_LINE('DEPTNO : ' ||c1_rec.DEPTNO);
   DBMS_OUTPUT.PUT_LINE('DNAME : ' ||c1_rec.DNAME);
   DBMS_OUTPUT.PUT_LINE('LOC : ' ||c1_rec.LOC);
  END LOOP;
END;
/


DECLARE
-- 테이블에서 특정 컬럼 구조 참조하기
  V_DEPTNO SCOTT.DEPT.DEPTNO%TYPE;
  
  --명시적 커서 선언
  CURSOR c1 (P_DEPTNO SCOTT.DEPT.DEPTNO%TYPE) IS
     SELECT DEPTNO, DNAME, LOC
     FROM SCOTT.DEPT
     WHERE DEPTNO = P_DEPTNO;
BEGIN
V_DEPTNO := &INPUT_DEPTNO;
  FOR c1_rec IN c1(V_DEPTNO)
  LOOP  
   DBMS_OUTPUT.PUT_LINE('DEPTNO : ' ||c1_rec.DEPTNO);
   DBMS_OUTPUT.PUT_LINE('DNAME : ' ||c1_rec.DNAME);
   DBMS_OUTPUT.PUT_LINE('LOC : ' ||c1_rec.LOC);
  END LOOP;
END;
/




--묵시적(선언X) : DML, SELECT~INTO(결과가 단일행)
--SQL%FOUND(묵시적 커서가 추출한 행이 있는 경우 TRUE)
--SQL%NOTFOUND(묵시적 커서가 추출한 행이 있는 경우 FALSE)
--SQL%ISOPEN(묵시적 커서가 자동으로 SQL 문 실행 후 닫기 때문에 항상 FALSE)
--SQL%FOUND(묵시적 커서에 현재까지 추출한 행 수 혹은 DML 영항 받은 행수)


BEGIN  
  UPDATE userTBL SET addr = '전라도'
  WHERE no = 2;
  
  DBMS_OUTPUT.PUT_LINE('갱신된 행의 수 : ' || SQL%ROWCOUNT);
  
  IF(SQL%FOUND) THEN 
   DBMS_OUTPUT.PUT_LINE('갱신된 행의 존재 여부 :  TRUE');
  ELSE
    DBMS_OUTPUT.PUT_LINE('갱신된 행의 존재 여부  FALSE');
   END IF;
   
   IF(SQL%ISOPEN) THEN
   DBMS_OUTPUT.PUT_LINE('커서의 오픈 여부 : TRUE');
   ELSE 
   DBMS_OUTPUT.PUT_LINE('커서의 오픈 여부 : FALSE');
   END IF;
END;
/