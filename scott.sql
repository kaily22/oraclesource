--scott 소유의 모든 테이블 조회
select * from tab;

--bonus 테이블에서 모든 내용 조회
select * from Bonus;

--emp 테이블의 모든 내용 조회
select * from emp;

--emp 테이블의 empno, ename
select empno, ename from emp;

--emp 테이블의 empno, JOB, HIREDATE 내용 조회
select empno, job, hiredate from emp;

--중복된 값 제거 : distinct
select deptno from emp;
select DISTINCT deptno from emp;

--별칭 
select empno from emp;
select empno as 사원번호 from emp;
select empno 사원번호 from emp;
select empno "사원번호" from emp;

select * from emp_tmp;



select * FROM emp;

select ename,sal, sal*12+comm as 연봉, comm from emp; 

select ename as 사원명, job as "직 책" from emp;

select 
 *
 from emp;
 
 --정렬 : ORDER BY 정렬 하려는 열 이름 정렬옵션(ASC(오름차순), DESC(내림차순))
 --ENAME, SAL 조회(SAL 내림차순)
 
 select ename, sal from emp order by sal DESC;
 select ename, sal from emp order by sal;
 
 --전체 데이터를 조회할 때 SAL 내림차순 
 select * from emp order by sal DESC;
 
 --EMPNO, ENAME, JOB, 조회할 때 EMPNO의 오름차순으로 조회
 select empno, ename, job from emp order by empno ASC;
 
 --부서번호의 오름차순과 급여의 내림차순 정렬하기
 select* from emp order by deptno ASC, sal DESC;
 
 select empno as EMPLOYEE_NO, ename as EMPLOYEE_NAME, mgr as MANAGER,
 sal as SALARY, comm as COMMISSION, deptno as DEPARTMENT_NO
 from emp
 order by deptno DESC, ename;
 
 --WHERE : 조건에 맞춰서 조회를 하고 싶을때
 
 --부서번호가 30번인 사원 조회
 select * from emp where deptno = 30;
 
 --사원번호가 7782인 사원 정보 조회
select * from emp where empno = 7782;

--부서번호가 30이고 사원직책이 salesman인 사원 조회
select * from emp where deptno = 30 AND job = 'SALESMAN';

--부서번호가 30이거나 사원직책이 CLERK인 사원 조회
select * from emp where deptno = 30 OR job = 'CLERK';




--산술연산자 : + - * / 
select * from emp where sal*12 = 36000;

--비교연산자 : > < >= <= 

--SAL의 값이 3000 이상인 사원 조회
select * from emp where sal >= 3000;

--급여가 2500이고, 직업이 analyst 사원 조회
select * from emp where sal > 2500 AND job = 'ANALYST';

--사원 이름의 첫 문자가 f와 같거나 뒤쪽인 것만 조회
select * from emp where ename >= 'F';

--직무가 manager, salesman, clerk인 사원 조회
select * from emp where job = 'MANAGER' OR job = 'SALESMAN' OR job = 'CLERK';


--등가 비교 연산자( =(동등), !=, <>, ^=, )
--sal 3000이 아닌 사원정보 출력
select * from emp where sal <> 3000;

--논리 부정 연산자 : NOT
select * from emp where NOT sal=3000;

--IN : = 
select * from emp where job IN ('MANAGER', 'SALESMAN', 'CLERK');

select * from emp where job != 'MANAGER' AND job ^= 'SALESMAN' AND job <> 'CLERK';
select * from emp where job NOT IN ('MANAGER', 'SALESMAN', 'CLERK');


--부서번호가 10, 20 사원 조회 
select * from emp where deptno IN (10,20);

--BETWEEN A AND B : 특정 범위의 데이터를 조회

--SAL 2000이상 - 3000 이하 
select * from emp where sal between 2000 AND 3000;

--SAL 2000이상 - 3000 이하가 아닌 사원 조회
select * from emp where sal not between 2000 AND 3000;


--LIKE 연산자와 와일드 카드
--사원 이름이 S로 시작하는 사원 (뒤에 개수와 상관없이)
select * from emp where ename LIKE 'S%';

--사원 이름의 두번째 글자가 L (문자 한 자 : _ ,)
select * from emp where ename LIKE '_L%';

--사원 이름에 AM이 포함되어 있는 사원 조회
select * from emp where ename LIKE '%AM%';

--사원 이름에 am 포함 x
select * from emp where ename not like '%AM%';




-- IS NULL 
--DB에서의 NULL -> 값이 존재하지 않음 / 해당사항 없음 / 확정되지 않은 값

SELECT * FROM EMP WHERE COMM IS NULL;
SELECT * FROM EMP WHERE MGR IS NULL;
SELECT * FROM EMP WHERE NOT MGR IS NULL;
SELECT * FROM EMP WHERE MGR IS NOT NULL;


--집합 연산자 : UNION(합집합 -> 중복 제거), UNION ALL(합집합 -> 중복 포함), 
--MINUS(차집합), INTERSECT(교집합)

--10번 부서와 20번 부서 조회
SELECT * FROM EMP WHERE DEPTNO = 10 
UNION 
SELECT * FROM EMP WHERE DEPTNO = 20;

SELECT * FROM EMP WHERE DEPTNO = 10 
UNION ALL
SELECT * FROM EMP WHERE DEPTNO = 20;

SELECT * FROM EMP WHERE DEPTNO = 10 
UNION ALL
SELECT * FROM EMP WHERE DEPTNO = 10;

SELECT * FROM EMP
MINUS
SELECT * FROM EMP WHERE DEPTNO = 10;

SELECT * FROM EMP
INTERSECT
SELECT * FROM EMP WHERE DEPTNO = 10;



--20번 30번 부서에 근무하고 있는 사원 중 급여가 2000 초과인 사원을 집합 연산자를
--사용해서 조회하기

SELECT * FROM EMP
WHERE  SAL>2000
MINUS
SELECT * FROM EMP
WHERE DEPTNO = 10;

SELECT * FROM EMP
WHERE DEPTNO = 20 AND SAL>2000
UNION
SELECT * FROM EMP
WHERE DEPTNO = 30 AND SAL>2000;

-- 함수(단독으로 사용)
-- 내장함수 : 오라클에서 기본적으로 제공하는 함수
-- 사용자 정의 함수


--문자 함수 1) 대소문자
SELECT ENAME, UPPER(ENAME), LOWER(ENAME), INITCAP(ENAME) FROM EMP;

--ORACLE, oracle, Oracle => 입력값 다양
--where lower(title) like '%oracle%'

--문자 함수 2)길이 LENGTHB(BYTE) -> 한글 하나당 3BYTE 할당
SELECT LENGTH('한글'), LENGTHB('한글') FROM DUAL;

-- ENAME 길이
SELECT ENAME, LENGTH(ENAME) FROM EMP;

--ENAME 길이가 5 이상인 사원 조회
SELECT ENAME FROM EMP WHERE LENGTH(ENAME) >= 5;

--문자 함수 : 3) 문자열 추출
SELECT JOB, SUBSTR(JOB,1,2) , SUBSTR(JOB,3,2), SUBSTR(JOB,5)
FROM EMP;

--EMP 테이블의 모든 사원 이름을 세번째 글자부터 끝까지 출력하기
--원 이름, 세번째~~
SELECT ENAME, SUBSTR(ENAME,3) FROM EMP;


-- 문자열 함수 : 4) 특정 문자의 위치 찾기
SELECT INSTR('HELLO, ORACLE!','L') AS 첫번째, INSTR('HELLO, ORACLE!','L',5) AS  두번째,
INSTR('HELLO, ORACLE!','L',2,2) AS 세번째 FROM DUAL;

SELECT INSTRB('이것이 Oracle이다. 이것도 오라클이다', '이것',2) FROM DUAL;


--사원 이름에 S가 있는 사원 조회
SELECT * FROM EMP WHERE INSTR(ENAME, 'S') >0 ;

--문자열 함수 : 5) 문자열 대체
SELECT REPLACE('이것이 오라클이다', '이것이', 'This is') FROM DUAL;

--010-1234-5678, 010 1234 5678
SELECT '010-1234-5678', REPLACE('010-1234-5678','-', ' '), 
REPLACE('010-1234-5678', '-') FROM DUAL;


--문자열 함수 : 6) 문자열 연결 
SELECT CONCAT(EMPNO, ENAME), CONCAT(EMPNO,CONCAT(':', ENAME))
FROM EMP WHERE ENAME = 'SMITH';

--CONCAT() = ||
SELECT (EMPNO||ENAME), EMPNO||':'|| ENAME
FROM EMP WHERE ENAME = 'SMITH';

--문자열 함수 : 7) 특정 문자 제거 - TRIM(양쪽), LTRIM, RTRIM
SELECT '          이것이         ', TRIM('          이것이         ') FROM DUAL;
SELECT '          이것이         ', LTRIM('          이것이         ') FROM DUAL;
SELECT '          이것이         ', RTRIM('          이것이         ') FROM DUAL;

SELECT '[' || TRIM(' __ORACLE__ ') || ']' AS TRIM,
'[' || LTRIM(' __ORACLE__ ') || ']' AS LTRIM,
'[' || RTRIM(' __ORACLE__ ') || ']' AS RTRIM FROM DUAL;

--문자열 함수 : 8) 문자열 반대로 처리
SELECT REVERSE('ORACLE') FROM DUAL;

--숫자 함수 : 반올림/올림/버림/나머지 값
SELECT ROUND(1234.5678) AS ROUND, ROUND(1234.5678,0) AS ROUND0,
       ROUND(1234.5678,1) AS ROUND1, ROUND(1234.5678,2) AS ROUND2,
       ROUND(1234.5678,-1) AS ROUND_MINUS1, ROUND(1234.5678,-2) AS ROUND_MINUS2
FROM DUAL;

--버림
SELECT TRUNC(1234.5678) AS TRUNC, TRUNC(1234.5678,0) AS TRUNC0,
       TRUNC(1234.5678,1) AS TRUNC1, TRUNC(1234.5678,2) AS TRUNC2,
       TRUNC(1234.5678,-1) AS TRUNC_MINUS, TRUNC(1234.5678,-2) AS TRUNC_MINUS2
FROM DUAL;

--지정한 숫자와 가장 가까운 정수를 찾는 CEIL(큰 정수), FLOOR(작은 정수)
SELECT CEIL(3.14), FLOOR(3.14), CEIL(-3.14), FLOOR(-3.14) 
FROM DUAL;

--나머지
SELECT MOD(15,6) , MOD(10,2), MOD(11,2)
FROM DUAL;

--날짜 함수 : SYSDATE (오라클 서버가 설치된 OS 현재날짜와 시간)
SELECT SYSDATE FROM DUAL;
SELECT SYSDATE AS NOW, SYSDATE-1 AS YESTERDAY, SYSDATE+1 AS TOMORROW 
FROM DUAL;

--몇 개월 이후의 날짜 구하기 : ADD_MONTHS
SELECT SYSDATE, ADD_MONTHS(SYSDATE, 3) FROM DUAL;

--입사 10주년이 되는 날짜 구하기
SELECT EMPNO, ENAME, HIREDATE , ADD_MONTHS(HIREDATE,120) FROM EMP;

--현재 날짜를 기준으로 입사 45년 미만인 사원 조회
SELECT * FROM EMP WHERE SYSDATE < ADD_MONTHS(HIREDATE,540);

--두 날짜 사이의 차이 출력 : MONTHS_BETWEEN
SELECT * FROM EMP WHERE MONTHS_BETWEEN(SYSDATE, HIREDATE) < 540;


SELECT EMPNO, ENAME, HIREDATE, SYSDATE,  
MONTHS_BETWEEN(SYSDATE, HIREDATE) AS MONTHS1, 
MONTHS_BETWEEN(HIREDATE, SYSDATE) AS MONTHS2,
TRUNC(MONTHS_BETWEEN(SYSDATE, HIREDATE)) AS MONTHS3
FROM EMP;

--돌아오는 요일(NEXT_DAY), 달의 마지막 날짜(LAST_DAY)
SELECT SYSDATE, NEXT_DAY(SYSDATE, '월요일'), LAST_DAY(SYSDATE) FROM DUAL;

--자료형 변환 함수 

--1) TO_CHAR() : 날짜, 숫자 데이터를 문자로 변환
SELECT TO_CHAR(SYSDATE,'YYYY/MM/DD') AS 현재날짜 FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'MM') AS 현재월 FROM DUAL;
SELECT TO_cHAR(SYSDATE, 'MON') AS 현재월 FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'DD') AS 현재일자 FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'DAY') AS 현재일자 FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'DD') AS 현재일자 FROM DUAL;

SELECT TO_cHAR(SYSDATE, 'HH:MI:SS PM') AS 현재시간 FROM DUAL;

--TO_NUMBER() : 문자를 숫자 데이터 형식으로 변환
SELECT 1300-'1500', '1300'+1500 FROM DUAL;

SELECT 1300-TO_NUMBER('1,500' ,'999,999'), TO_NUMBER('1,300','999,999')+1500 FROM DUAL;

-- TO_DATE() : 문자 데이터를 날짜형 데이터로 변환 
SELECT TO_DATE('2021-04-16') AS TODATE1, TO_DATE('20210416') AS TODATE2 FROM DUAL;

SELECT TO_DATE('2021-04-16') - TO_DATE('2021-04-12') FROM DUAL;

-- 널처리 함수 -NVL(), NVL2()
SELECT EMPNO, ENAME, SAL, COMM, SAL+COMM FROM EMP;
SELECT EMPNO, ENAME, SAL, COMM, SAL+NVL(COMM,0) FROM EMP;

--NVL2(널 열, 널이 아닐경우 반환할 값, 널일 경우 반환할 값)
SELECT EMPNO, ENAME, SAL, COMM, NVL2(COMM,'0','X'), SAL+NVL2(COMM, SAL*12+COMM, SAL*12)
FROM EMP;


--DECODE 함수
SELECT EMPNO, ENAME, JOB, SAL, DECODE(JOB,
                                        'MANAGER', SAL*1.1, 
                                        'SALESMAN',SAL*1.05,
                                        'ANALYST', SAL,
                                        SAL*1.03) AS UPSAL
FROM EMP;

--CASE (DECODE 범용성이 높다)
SELECT EMPNO, ENAME, JOB, SAL, CASE JOB
                                        WHEN 'MANAGER' THEN SAL*1.1
                                        WHEN 'SALESMAN' THEN SAL*1.05
                                        WHEN 'ANALYST' THEN SAL
                                        ELSE SAL*1.03 
                                        END AS UPSAL
FROM EMP;

SELECT EMPNO, ENAME, JOB, SAL,
       CASE 
          WHEN COMM IS NULL THEN '해당사항 없음'
          WHEN COMM = 0 THEN '수당 없음'
          WHEN COMM > 0 THEN '수당 : '|| COMM
        END AS COMM_TEXT FROM EMP;

--1
SELECT EMPNO ENAME, SAL, TRUNC(SAL / 21.5, 2)  AS DAY_PAY, ROUND(SAL /21.5/8 , 1) AS TIME_PAY
FROM EMP;


--2
SELECT EMPNO, ENAME, HIREDATE, 
NEXT_DAY(ADD_MONTHS(HIREDATE, 3),'월요일') AS R_JOB, 
NVL(TO_CHAR(COMM),'N/A') AS COMM FROM EMP;

--3
SELECT EMPNO, ENAME, MGR, DECODE(SUBSTR(TO_CHAR(MGR),1,2),
                                 NULL, '0000',
                                 '75', '5555',
                                 '76', '6666',
                                 '77', '7777',
                                 '78', '8888',
                                 SUBSTR(TO_CHAR(MGR),1)) AS CHG_MGR   
FROM EMP;

SELECT EMPNO, ENAME, MGR, CASE WHEN MGR IS NULL THEN '0000'
                             WHEN SUBSTR(TO_CHAR(MGR),1,2) = '75'  THEN '5555'
                             WHEN SUBSTR(TO_CHAR(MGR),1,2) = '76' THEN '6666'
                             WHEN SUBSTR(TO_CHAR(MGR),1,2) = '77' THEN '7777'
                             WHEN SUBSTR(TO_CHAR(MGR),1,2) = '78' THEN '8888'
                             ELSE TO_CHAR(MGR)
                             END AS CHG_MGR
FROM EMP;


--다중행 함수 : SUM, COUNT, MAX, MIN, AVERAGE
SELECT SUM(COMM) FROM EMP;

SELECT COUNT(*) FROM EMP;

SELECT COUNT(*) FROM EMP WHERE DEPTNO = 30;

SELECT COUNT(DISTINCT SAL), COUNT(SAL) FROM EMP;

SELECT MAX(SAL), MIN(SAL) FROM EMP;

SELECT MAX(HIREDATE), MIN(HIREDATE) FROM EMP;

--부서 번호가 20인 사람중에 가장 오래 일한 사람
SELECT MIN(HIREDATE) FROM EMP WHERE DEPTNO = 20;

SELECT AVG(SAL) FROM EMP ;

--GROUP BY : 결과 값을 원하는 열로 묶어 출력
SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO;

--부서번호, 직책별 평균 급여 구하기
SELECT DEPTNO, JOB,  AVG(SAL) FROM EMP 
GROUP BY DEPTNO, JOB 
ORDER BY DEPTNO, JOB;

--각 부서의 직책별 평균 급여를 구하되, 평균 급여가 2000 이상인 그룹 출력
-- HAVING 절 : GROUP BY 절에 조건을 줄 때 사용
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) > 2000
ORDER BY DEPTNO, JOB;

--부서별 직책의 평균 급여가 500 이상인 사원들의 부서 번호, 직책, 부서별 직책의 평균
--급여 조회
SELECT DEPTNO, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL)>=500
ORDER BY DEPTNO, JOB;

-- 문) 부서번호, 평균급여, 최고급여, 최저급여, 사원 수 출력하기
-- 단, 평균 급여를 출력할 때 소수점을 제외하고 각 부서별로 출력
SELECT DEPTNO, FLOOR(AVG(SAL)), MAX(SAL), MIN(SAL), COUNT(EMPNO)
FROM EMP
GROUP BY DEPTNO;

--문) 같은 직책에 종사하는 사원이 3명 이상인 직책과 인원수 출력
SELECT COUNT(*),JOB
FROM EMP
GROUP BY JOB
HAVING COUNT(JOB) >=3 ;

--문) 사원들의 입사연도를 기준으로 부서별로 몇 명이 입사했는지 추력
SELECT DEPTNO, TO_CHAR(HIREDATE, 'YYYY') AS 입사연도, COUNT(*) 
FROM EMP
GROUP BY DEPTNO , TO_CHAR(HIREDATE, 'YYYY');

SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB HAVING AVG(SAL) >=2000 ORDER BY DEPTNO, JOB;


SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
WHERE SAL <= 3000
GROUP BY DEPTNO, JOB HAVING AVG(SAL) >=2000 ORDER BY DEPTNO, JOB;

--JOIN(조인)
--등가조인(INNER JOIN(내부조인), 단순조인)
SELECT * FROM DEPT;
SELECT * FROM EMP;

--column ambiguously defined
SELECT EMPNO, ENAME, E.DEPTNO, DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

-- 카테시안 조인(나올 수 있는 모든 조합) 조인
SELECT * FROM EMP, DEPT ORDER BY EMPNO;

--EMP 테이블의 DEPTNO 와 DEPT 테이블의 DEPTNO가 일치하는 회원들의 
--사원번호, 이름, 부서번호, 부서명 조회(단, 급여가 3000이상인 사원 출력)
SELECT EMPNO, ENAME, E.DEPTNO, DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND SAL >= 3000;


--EMP테이블 별칭을 E로, DEPT 테이블 별칭을 D로 하여 급여가 2500 이상이고
--사원번호가 9999이하인 사원들의 정보 출력
--EMPNO, ENAME, SAL, DEPTNO, DNAME, LOC를 출력
SELECT EMPNO, ENAME, SAL, E.DEPTNO, DNAME, LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND SAL>=2500 AND EMPNO<9999;

--EMP 테이블 별칭을 E로, SALGRADE 테이블 별칭을 S로 하여 각 사원의 정보와
--사원의 급여 등급 정보를 출력하기
SELECT * FROM SALGRADE;

--비등가 조인
SELECT E.EMPNO, E.ENAME, E.SAL, E.DEPTNO, E.JOB, E.MGR, E.HIREDATE, E.SAL,
E.COMM, S.GRADE
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

--자체조인(SELF JOIN) : 조인을 할 때 두번째 테이블이 자기 자신
SELECT * FROM EMP;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_NAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;

--외부 조인

--왼쪽 외부 조인 WHERE TABLE1.COL1 = TABLE2.COL1(+)
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_NAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+);

--오른쪽 외부 조인 WHERE TABLE1.COL1(+) = TABLE2.COL1
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_NAME
FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO;

-- + 기호를 붙이는 외부 조인 방식은 전체 외부 조인 구현 불가능 FULL OUTER JOIN
--SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_NAME
--FROM EMP E1, EMP E2
--WHERE E1.MGR(+) = E2.EMPNO(+);

--표준문법 조인
--NATURAL JOIN (등가조인)
SELECT E.EMPNO, E.ENAME, DEPTNO, D.DNAME
FROM EMP E NATURAL JOIN DEPT D ORDER BY DEPTNO, E.EMPNO;

--JOIN~ON
SELECT E.EMPNO, E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D ON E.DEPTNO = D.DEPTNO
ORDER BY DEPTNO, E.EMPNO;

--OUTER JOIN ~ON
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_NAME
FROM EMP E1 LEFT OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_NAME
FROM EMP E1 RIGHT OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_NAME
FROM EMP E1 FULL OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;

SELECT * FROM DEPT;
SELECT * FROM EMP;

-- 1) 각 부서별 평균급여, 최대급여, 최소 급여, 사원수를 출력하기
--단, 부서번호, 부서명, 평균, 최대, 최소, 사원수 형태로 출력
--EMP,DEPT 조인
SELECT D.DEPTNO, D.DNAME, FLOOR(AVG(SAL)),MAX(SAL), MIN(SAL), COUNT(*)
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO GROUP BY D.DEPTNO, D.DNAME;

--2) 모든 부서정보와(아우터조인) 사원 정보를 부서번호, 부서명, 사원번호, 사원명, 직무, 급여 형태로
--출력하기(EMP, DEPT 조인)
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM DEPT D LEFT OUTER JOIN EMP E ON D.DEPTNO = E.DEPTNO ;

--3) 급여가 2천 초과인 사원들의 부서정보, 사원정보 출력(SQL 표준 문법으로 작성)
--부서번호, 부서명, 사원번호, 사원명, 급여 순으로 출력

SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM EMP E JOIN DEPT D ON E.SAL > 2000;



--세 개의 테이블 조인

--기존 방식
SELECT E1.EMPNO AS EMPNO_E1, E2.EMPNO AS EMPNO_E2, E3.EMPNO AS EMPNO_E3
FROM EMP E1, EMP E2, EMP E3
WHERE E1.EMPNO = E2.EMPNO AND E2.EMPNO = E3.EMPNO;

--표준 방식
SELECT E1.EMPNO AS EMPNO_E1, E2.EMPNO AS EMPNO_E2, E3.EMPNO AS EMPNO_E3
FROM EMP E1 JOIN EMP E2 ON  E1.EMPNO = E2.EMPNO 
     JOIN EMP E3 ON  E2.EMPNO = E3.EMPNO;
     
--모든 부서 정보와 사원 정보를 부서 번호, 부서명, 사원번호, 사원명, 직무, 급여
--부서번호, 사원이름 오름차순으로 정렬(OUTER JOIN 3개)

--RIGHT OUTER JOIN
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME
FROM EMP E,DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO
ORDER BY DEPTNO;


SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL, E.MGR, S.LOSAL, S.HISAL, S.GRADE, 
       E2.EMPNO AS MGR_EMPNO, E2. ENAME AS MGR_ENAME
FROM EMP E, DEPT D, SALGRADE S, EMP E2
WHERE E.DEPTNO(+) = D.DEPTNO AND
    E.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+) 
    AND E.MGR = E2.EMPNO(+)
    ORDER BY D.DEPTNO, E.ENAME;
    
--표준 
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL, E.MGR, S.LOSAL, S.HISAL, S.GRADE, 
       E2.EMPNO AS MGR_EMPNO, E2. ENAME AS MGR_ENAME
FROM EMP E RIGHT OUTER JOIN DEPT D ON E.DEPTNO = D.DEPTNO
     LEFT OUTER JOIN SALGRADE S ON E.SAL BETWEEN S.LOSAL AND S.HISAL
     LEFT OUTER JOIN EMP E2 ON E.MGR = E2.EMPNO
ORDER BY D.DEPTNO, E.ENAME;


--서브 쿼리 : SQL 문을 실행하는데 필요한 데이터를 추가로 조회하기 위해 SQL 문 내부에서 사용하는 SELECT문
--JONES 라는 사람의 급여보다 높은 급여를 받는 사원 조회 

SELECT SAL FROM EMP WHERE ENAME = 'JONES'; --2975
SELECT * FROM EMP WHERE SAL > 2975;

--서브쿼리 사용
SELECT * FROM EMP WHERE SAL> (SELECT SAL FROM EMP WHERE ENAME = 'JONES');

--'ALLEN' 사원의 추가수당보다 많은 추가수당을 받는 사원 조회
SELECT * FROM EMP WHERE COMM > (SELECT COMM FROM EMP WHERE ENAME = 'ALLEN');

--WARD보다 빨리 입사한 사원 조회
SELECT * FROM EMP WHERE HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME = 'WARD');

-- 20번 부서에 속한 사원 중 전체 사원의 평균 급여보다 높은 급여를 받는 사원정보
SELECT * FROM EMP WHERE DEPTNO = 20 AND SAL > (SELECT AVG(SAL) FROM EMP);
--(사원번호, 사원명, 직무, 급여) 와 소속부서정보(부서번호, 부서명, 지역위치)를 조회
SELECT E.EMPNO, E.ENAME, E.JOB, E.SAL, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND E.DEPTNO = 20 
AND SAL > (SELECT AVG(SAL) FROM EMP);

-- 각 부서별 최고 급여와 동일한 급여 및 큰 급여를 받는 사원 정보를 조회
-- single-row subquery returns more than one row
-->= 단일행 서브쿼리
SELECT * FROM EMP WHERE SAL IN (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

--각 부서별 최고 급여와 동일한 급여를 받는 사원 정보 조회
SELECT * FROM EMP WHERE SAL = ANY (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);
SELECT * FROM EMP WHERE SAL = SOME (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

-- 30번 부서 사원들의 최대 급여보다 적은 급여를 받는 사원 정보 출력
SELECT * FROM EMP WHERE SAL < (SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30);

SELECT * 
FROM EMP
WHERE SAL < ANY (SELECT SAL FROM EMP WHERE DEPTNO = 30); --1600, 1250, 2850, 1500, 950


SELECT *
FROM EMP
WHERE SAL > ANY(SELECT SAL FROM EMP WHERE DEPTNO = 30);

-- ALL : 서브 쿼리의 모든 결과가 조건식에 맞아 떨어져야 메인 쿼리의 조건식이 TRUE됨
SELECT *
FROM EMP
WHERE SAL < ALL(SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30);


SELECT *
FROM EMP
WHERE SAL > ALL(SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30);

--EXISTS : 서브쿼리에 결과 값이 하나 이상 존재하면 조건식이 모두 TRUE, 존재하지 않으면 FALSE
--FALSE면 안나옴
SELECT *
FROM EMP
WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO = 50);


SELECT *
FROM EMP
WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO = 20);

SELECT EMPNO, DEPTNO
FROM EMP
WHERE EXISTS (SELECT DEPTNO
              FROM DEPT 
              WHERE DEPTNO IN (20,30) AND EMP.DEPTNO = DEP.DEPTNO);

-- 전체 사원 중 ALLEN과 같은 직책인 사원들의 사원정보, 부서 정보를 다음과 같이 출력하는 SQL문을 작성하시오.
SELECT E.JOB, E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME
FROM EMP E , DEPT D
WHERE E.DEPTNO = D.DEPTNO AND E.JOB = (SELECT JOB FROM EMP WHERE ENAME = 'ALLEN');

--전체 사원의 평균 급여보다 높은 급여를 받는 사원들의 사원정보, 부서정보, 급여 등급 정보를 출력하는 SQL문을 작성하시오(단, 출력할 때 급여가 많은 순으로 정렬하되 
--  급여가 같을 경우에는 사원 번호를 기준으로 오름차순으로 정렬하기)
SELECT E.EMPNO, E.ENAME, D.DNAME, E.HIREDATE, D.LOC, E.SAL, S.GRADE
FROM EMP E, DEPT D, SALGRADE S
WHERE E.DEPTNO = D.DEPTNO AND E.SAL BETWEEN S.LOSAL AND S.HISAL
                 AND E.SAL > (SELECT AVG(SAL) FROM EMP)
ORDER BY E.SAL DESC, E.EMPNO ASC;

--다중열 서브쿼리
--자신의 부서 내에서 최고 연봉과 동일한 급여를 받는 사원 추출
SELECT * 
FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL)
                        FROM EMP
                        GROUP BY DEPTNO);

SELECT DEPTNO, MAX(SAL)
FROM EMP
GROUP BY DEPTNO;

--서브 쿼리(FROM 절에 사용하는 서브쿼리 : 인라인 뷰)
--특정 테이블 전체 데이터가 아닌 SELECT 문을 통해 일부 데이터를 먼저 추출해 온 후 별칭
-- 붙여서 사용하는 방식
SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC
FROM (SELECT * FROM EMP WHERE DEPTNO = 10) E10,
     (SELECT * FROM DEPT) D
WHERE E10.DEPTNO = D.DEPTNO;

--서브 쿼리(SELECT 절에 사용하는 서브쿼리 : 스칼라 서브쿼리)
SELECT EMPNO, ENAME, JOB, SAL,(SELECT GRADE 
                               FROM SALGRADE 
                               WHERE E.SAL BETWEEN LOSAL AND HISAL) 
                               AS SALGRADE,
                               DEPTNO, (SELECT DNAME
                                       FROM DEPT
                                       WHERE E.DEPTNO = DEPT.DEPTNO) AS DNAME                                      
FROM EMP E;

--Q) 10번 부서에 근무하는 사원 중 30번 부서에는 존재하지 않는 직책을 가진 
--사원들의 사원정보, 부서 정보를 다음과 같이 출력하는 SQL문을 작성하시오.

SELECT E.EMPNO, E.ENAME, E.JOB, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND E.DEPTNO=10 AND E.JOB NOT IN(SELECT JOB FROM EMP WHERE DEPTNO = 30);

--Q) 책이 SALESMAN인 사람들의 최고 급여보다 높은 급여를 받는 사원들의 
--사원정보, 급여등급 정보를 출력하는 SQL문을 작성하시오(단, 서브쿼리를 활용할 때 
--다중행 함수를 사용하는 방법과 사용하지 않는 방법을 통해 사원번호를 기준으로 오름차순 정렬하여 출력하시오.)

SELECT EMPNO, ENAME, SAL,(SELECT GRADE FROM SALGRADE WHERE E.SAL BETWEEN LOSAL AND HISAL) AS GRADE
FROM EMP E
WHERE SAL > ( SELECT MAX(SAL) FROM EMP WHERE JOB = 'SALESMAN');

--사용하는 방법
SELECT EMPNO, ENAME, SAL,(SELECT GRADE FROM SALGRADE WHERE E.SAL BETWEEN LOSAL AND HISAL) AS GRADE
FROM EMP E
WHERE SAL > ALL ( SELECT SAL FROM EMP WHERE JOB = 'SALESMAN');

--데이터 삽입
--테이블 복제(테이블 구조와 내용이 모두 복사)
CREATE TABLE DEPT_TEMP AS SELECT * FROM DEPT;
SELECT * FROM DEPT_TEMP;

--INSERT 구문 형식 
INSERT INTO DEPT_TEMP VALUES (50,'DATABASE','SEOUL');
INSERT INTO DEPT_TEMP(DEPTNO, DNAME,LOC) VALUES (50, 'DATABASE','SEOUL');

--"not enough values"
INSERT INTO DEPT_TEMP(DEPTNO, DNAME) VALUES (60, 'NETWORK');


INSERT INTO DEPT_TEMP VALUES (70,'DATABASE2');

--value larger than specified 
INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC) VALUES(70, 'WEB',NULL);

--테이블 구조만 복제
CREATE TABLE EMP_TEMP AS SELECT * FROM EMP WHERE 1<>1;
SELECT * FROM EMP_TEMP;

INSERT INTO EMP_TEMP VALUES(9999,'홍길동', 'PRESIDENT', NULL, '2001/01/01',4000,NULL,10);

INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(1111,'성춘향','MANAGER',NULL,'2003-01-01', 5000, 1000,10);

INSERT INTO EMP_TEMP VALUES(2222,'유승호','MANAGER',1111,SYSDATE,5000, NULL,10);

--EMP 테이블에서 SALGRADE 테이블을 참조하여 급여 등급이 1인 사원마을 EMP_TEMP 추가
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE,E.SAL, E.COMM, E.DEPTNO
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE =1;

COMMIT;


--update : 데이터 수정
--set 변경할 열 명 = 변경할 값, 변경할 열 명 = 변경할 열 명 = 변경할 값
--where 조건(필수는 아님)

select * from dept_temp;

--테이블의 특정 열 값을 전체 수정

update dept_temp
set LOC = 'SEOUL'
where deptno = 80;

SELECT *
FROM EMP_TEMP;

--급여가 3000 이하인 사원만 추가 수당을 50으로 변경
UPDATE EMP_TEMP
SET COMM = 50
WHERE SAL <= 3000;


ROLLBACK;

--서브 쿼리를 사용하여 데이터 수정

create table dept_temp2 as select * from dept;
select * from dept_temp2;

UPDATE DEPT_TEMP2
SET(DNAME, LOC) = (SELECT DNAME, LOC
                   FROM DEPT 
                   WHERE DEPTNO = 40)
WHERE DEPTNO = 30;
ROLLBACK;


UPDATE dept_temp2
SET LOC = 'SEOUL'
WHERE DEPTNO = (SELECT DEPTNO
                FROM DEPT_TEMP2
                WHERE DNAME ='OPERATIONS');

SELECT * FROM DEPT_TEMP2;

ROLLBACK;


--DELETE : 테이블에 있는 데이터 삭제
--DELETE 테이블 WHERE 삭제 조건
--DELETE FROM 테이블 명 WHERE 삭제조건

CREATE TABLE EMP_TEMP2 AS SELECT * FROM EMP;
SELECT * FROM EMP_TEMP2;

ROLLBACK;

--전체 삭제
DELETE EMP_TEMP2;

--부분 삭제
--JOB이 매니저인 사람 삭제
DELETE 
FROM EMP_TEMP2
WHERE JOB = 'MANAGER';

ROLLBACK;
SELECT * FROM EMP_TEMP2;

--서브 쿼리를 사용하여 데이터 삭제
--급여 등급이 3등급이고 , 30번 부서의 사원만 삭제
-- <= 단일행 서브쿼리

DELETE FROM EMP_TEMP2
WHERE EMPNO IN
          (SELECT E.EMPNO
           FROM EMP_TEMP2 E, SALGRADE S
           WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
                  AND S.GRADE = 3 AND  E.DEPTNO=30);
ROLLBACK;

SELECT * FROM EMP_TEMP2;
--EMP_TEMP2 테이블에서 급여가 5천 이상인 사원 삭제
DELETE
FROM EMP_TEMP2
WHERE SAL >= 5000;


CREATE TABLE EXAM_EMP AS SELECT * FROM EMP;
CREATE TABLE EXAM_DEPT AS SELECT * FROM DEPT;
CREATE TABLE EXAM_SALGRADE AS SELECT * FROM SALGRADE;

SELECT * FROM EXAM_EMP;
INSERT INTO EXAM_EMP VALuES(7201,'TEST_USER1', 'MANAGER', 7788, '2016-01-02', 4500, null, 50);
INSERT INTO EXAM_EMP VALuES(7202,'TEST_USER2', 'MANAGER', 7201, '2016-02-21', 1800, null, 50);
INSERT INTO EXAM_EMP VALuES(7203,'TEST_USER3', 'MANAGER', 7201, '2016-04-11', 3400, null, 60);
INSERT INTO EXAM_EMP VALuES(7204,'TEST_USER4', 'MANAGER', 7201, '2016-05-31', 2700, 300, 60);
INSERT INTO EXAM_EMP VALuES(7205,'TEST_USER5', 'MANAGER', 7201, '2016-07-20', 2600, null, 70);
INSERT INTO EXAM_EMP VALuES(7206,'TEST_USER6', 'MANAGER', 7201, '2016-09-08', 2600, null, 80);
INSERT INTO EXAM_EMP VALuES(7207,'TEST_USER7', 'MANAGER', 7201, '2016-10-28', 2300, null, 80);
INSERT INTO EXAM_EMP VALuES(7208,'TEST_USER8', 'MANAGER', 7201, '2018-03-09', 1200, null, 80);

UPDATE EXAM_EMP
SET DEPTNO = 70
WHERE SAL > (SELECT AVG(SAL)
                  FROM EXAM_EMP
                  WHERE DEPTNO = 50);


UPDATE EXAM_EMP
SET SAL = SAL * 1.1, DEPTNO = 80
WHERE HIREDATE > (SELECT MIN(HIREDATE) 
FROM EXAM_EMP WHERE DEPTNO = 60);

DELETE FROM EXAM_EMP
WHERE EMPNO IN(SELECT E.EMPNO
                FROM EXAM_EMP E, SALGRADE S
                WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE=5);
COMMIT;

--트랜잭션 : 작업 수행의 최소 단위
-- commit(반영)/rollback(취소)

CREATE TABLE DEPT_TCL AS SELECT * FROM DEPT;

--DML실행 => 트랜잭션
INSERT INTO DEPT_TCL VALUES(50,'DATABASE','SEOUL');

UPDATE DEPT_TCL SET LOC = 'BUSAN' WHERE DEPTNO = 40;

DELETE FROM DEPT_TCL WHERE DNAME = 'RESEARCH';

SELECT * FROM DEPT_TCL;
--취소
ROLLBACK;

--반영
COMMIT;

-- 세션 : 어떤 활동을 위한 시간이나 기간 
--  데이터베이스 접속을 시작으려 어러 데이터베이스에서 관련 작업을 수행한 후
--  접속을 종료하기까지 전체 기간 


SELECT * FROM DEPT_TCL;  
DELETE 
FROM DEPT_tCL
WHERE DEPTNO = 50;
COMMIT;


UPDATE DEPT_TCL SET LOC = 'SEOUL'
WHERE DEPTNO = 30;

COMMIT;
SELECT * FROM DEPT_TCL;

--데이터 정의어(DDL) : 여러 객체의 생성, 변경, 삭제, 기능 제공
                    --AUTO COMMIT 구문

--create, alter, drop

--테이블 생성
--create table 테이블명 (열1 이름 자료형, 열2이름 자료형.....);


--테이블 명 생성 규칙 
--문자로 시작(영어, 한글, 숫자 0~9, 특수문자 $,_, # 가능)
--테이블명은 30 BYTE 이하/
--같은 사용자 소유의 테이블 이름은 중복 X
--키워드는 테이블명 사용 불가(select, delete...)


CREATE TABLE EMP_DDL(
 EMPNO NUMBER(4),
 ENAME VARCHAR2(10),
 JOB VARCHAR2(9),
 MGR NUMBER(4),
 HIREDATE DATE,
 SAL NUMBER(7,2),
 COMM NUMBER(7,2), --전체 자릿수는 7자리인데 그 중 소수점 자릿수를 2자리로 하겠다
 DEPT NUMBER(2)
);

--문자 타입 : CHAR(10), NCHAR(10), VARCHAR(10), NVARCHAR2(10)
--N : 유니코드, V: Variable(가변)
--CHAR : 고정길이 문자형
--NCHAR: 유니코드 고정길이 문자형
--VARCHAR2 : 가변길이 문자형(바이트 단위)
--NVARCHAR2 : 유니코드 가변길이 문자형

SELECT * FROM EMP_DDL;

CREATE TABLE TEST(
  ID NUMBER(4),
  NAME VARCHAR(3));

DESC TEST;

INSERT INTO TEST(ID, NAME) VALUES(10, '홍길동');
--삽입 잘됨
INSERT INTO TEST(ID, NAME) VALUES(10, 'LKG');

CREATE TABLE TEST2(
  ID NUMBER(4),
  NAME NCHAR(3)); --문자 그대로의 갯수를 의미(고정길이를 사용하겠음)
  
INSERT INTO TEST2(ID,NAME) VALUES(10,'홍길동');
INSERT INTO TEST2(ID,NAME) VALUES(20,'박');

CREATE TABLE TEST3(
   ID NUMBER(4),
   NAME NVARCHAR2(3)); --문자 그대로의 갯수를 의미(가변길이를 사용하겠음)
   
INSERT INTO TEST3(ID, NAME) VALUES(10,'홍길동');
INSERT INTO TEST3(ID, NAME) VALUES (20, '박');

SELECT * FROM TEST2 WHERE NAME = '박';

CREATE TABLE DEPT_DDL AS SELECT* FROM DEPT;
CREATE TABLE DEPT_DDL_30 AS SELECT * FROM DEPT WHERE DEPTNO = 30;
CREATE TABLE DEPT_DDL2 AS SELECT * FROM DEPT WHERE 1<>1;
   
--DROP : 삭제
DROP TABLE DEPT_DDL2;

--ALTER : 수정

CREATE TABLE EMP_ALTER AS SELECT * FROM EMP;
SELECT * FROM EMP_ALTER;

--테이블 컬럼 추가하기
ALTER TABLE EMP_ALTER ADD HP VARCHAR(20);

--열 이름 변경하기 : RENAME 
ALTER TABLE EMP_ALTER RENAME COLUMN HP TO TEL;

--열 자료형 변경하기 
ALTER TABLE EMP_ALTER MODIFY EMPNO NUMBER(5);
DESC EMP_ALTER;

--특정 열을 삭제
ALTER TABLE EMP_ALTER DROP COLUMN TEL;

--테이블의 이름 변경 : RENAME
RENAME EMP_ATLER TO EMP_RENAME;

SELECT * FROM EMP_RENAME;
DESC EMP_RENAME;


--[실습] MEMEBER 테이블 작성

DROP TABLE MEMBER;
CREATE TABLE MEMBER (
ID CHAR(8),
NAME VARCHAR2(10), --NVARCHAR2 가능
ADDR VARCHAR2(50),
NATION NCHAR(4),
EMAIL VARCHAR(50),
AGE NUMBER(7,2)
);

ALTER TABLE MEMBER ADD  BIGO VARCHAR2(20);

ALTER TABLE MEMBER MODIFY BIGO VARCHAR2(30);

ALTER TABLE MEMBER RENAME COLUMN BIGO TO REMARK; 

select * FROM MEMBER;

INSERT INTO MEMBER (ID, NAME, ADDR, NATION, EMAIL, AGE) VALUES('hong1234','홍길동', '서울시 구로구 개봉동', '대한민국','hong123@naver.com',25);
INSERT INTO MEMBER (ID, NAME, ADDR, NATION, EMAIL, AGE)VALUES('hong1235','이승기', '서울시 강서구 화곡동', '대한민국','lee89@naver.com',26);
INSERT INTO MEMBER (ID, NAME, ADDR, NATION, EMAIL, AGE)VALUES('hong1236','강호동', '서울시 마포구 상수동', '대한민국','kang56@naver.com',42);
INSERT INTO MEMBER (ID, NAME, ADDR, NATION, EMAIL, AGE) VALUES('hong1237','이수근', '경기도 부천시',       '대한민국','leesu@naver.com',42);
INSERT INTO MEMBER (ID, NAME, ADDR, NATION, EMAIL, AGE)VALUES('hong1238','서장훈', '서울시 강남구 대치동', '대한민국','seo568@naver.com',36);
INSERT INTO MEMBER (ID, NAME, ADDR, NATION, EMAIL, AGE)VALUES('hong1239','김영철', '서울시 도봉구 개봉동', '대한민국','young@naver.com',41);
INSERT INTO MEMBER (ID, NAME, ADDR, NATION, EMAIL, AGE)VALUES('hong1210','김장훈', '서울시 노원구 노원1동', '대한민국','kim@naver.com',48);
INSERT INTO MEMBER (ID, NAME, ADDR, NATION, EMAIL, AGE)VALUES('hong1211','임창정', '서울시 양천구 신월동', '대한민국','limchang@naver.com',45);
INSERT INTO MEMBER (ID, NAME, ADDR, NATION, EMAIL, AGE)VALUES('hong1212','김종국', '서울시 강남구 도곡동', '대한민국','kimjong@naver.com',44);
INSERT INTO MEMBER (ID, NAME, ADDR, NATION, EMAIL, AGE)VALUES('hong1213','김범수', '경기도 일산동구 일산동','대한민국','kim77@naver.com',36);
INSERT INTO MEMBER (ID, NAME, ADDR, NATION, EMAIL, AGE)VALUES('hong1214','김경호', '인천시 서구 가좌동',  '대한민국','hong789@naver.com',26);
INSERT INTO MEMBER (ID, NAME, ADDR, NATION, EMAIL, AGE)VALUES('hong1215','민경훈', '경기도 수원시 수원1동', '대한민국','min@naver.com',35);
INSERT INTO MEMBER (ID, NAME, ADDR, NATION, EMAIL, AGE)VALUES('hong1216','바이브', '경기도 용인시 기흥구', '대한민국','vibe@naver.com',33);

SELECT * FROM MEMBER;

UPDATE MEMBER SET REMARK = '';
DROP TABLE MEMBER;



SELECT * FROM EMP_TEMP;

--데이터 사전 : DB를 구성하고 운영하는데 필요한 정보를 담는 특수한 테이블
--직접 접근은 불가하고 뷰를 통해서 접근

SELECT * FROM DICT;

--USER:현재 오라클에 접속되어 있는 사용자가 소유한 객체 정보
--scott 계정이 가지고 있는 테이블 정보

SELECT TABLE_NAME FROM USER_TABLES;

--ALL_ : 다른 사용자가 소유한 객체 중 사용이 허락되어 있는 객체 정보
SELECT * FROM ALL_TABLES;

SELECT * FROM DBA_TABLES;


--인덱스(직접 생성 / 기본키(PK) OR 고유키(UNIQUE)로 설정하면 자동으로 생성)
SELECT * FROM USER_INDEXES;

--직접 생성
CREATE INDEX IDX_EMP_SAL ON EMP(SAL);

SELECT * FROM EMP 
WHERE SAL = 1600;

--삭제 
DROP INDEX IDX_EMP_SAL;


--INDEX 자동 생성
CREATE TABLE USERTBL (
USERID CHAR(8) NOT NULL PRIMARY KEY,
USERNAME NVARCHAR2(10) NOT NULL,
BIRTHYEAR NUMBER(4) NOT NULL, 
MOBILE CHAR(3));

SELECT INDEX_NAME, UNIQUENESS, INDEX_TYPE FROM USER_INDEXES;

SELECT * FROM EMP_TEMP;



--뷰(VIEW) : 가상 테이블 (SELECT 문 저장)
--insufficient privileges(권한 불충분)
--권한 부여 한 후 실행
CREATE VIEW VM_EMP20 AS (SELECT EMPNO, ENAME, JOB, DEPTNO FROM EMP WHERE DEPTNO = 20);

SELECT * FROM VM_EMP20;
SELECT * FROM USER_VIEWS;

--뷰 삭제
DROP VIEW VM_EMP20;

--뷰에 데이터 입력? => 원본도 변경이 됨
INSERT INTO VM_EMP20 VALUES(7903,'JAMES','MANAGER',20);
SELECT * FROM VM_EMP20;
SELECT * FROM EMP;

--"cannot perform a DML operation on a read-only view"
--원본 데이터를 수정 할 수 없도록 뷰 생성
CREATE VIEW VM_EMP_READ AS SELECT EMPNO, ENAME, JOB FROM EMP WITH READ ONLY; 


--인라인 뷰
SELECT ROWNUM, E.*
FROM EMP E;

--시퀀스 : 특정 규칙에 맞는 연속 숫자 생성
--      : 게시판 글 번호, 상품 주문 번호 생성 시 사용
--시퀀스 생성(데이터 안가져오고 구조만)
CREATE TABLE DEPT_SEQUENCE AS SELECT* FROM DEPT WHERE 1<>1;
SELECT * FROM DEPT_SEQUENCE;


CREATE SEQUENCE SEQ_DEPT_SEQUENCE -- 필수 
INCREMENT BY 10 --  기본 값 : 1           --이 구문부터 아래까지는 생략 가능
START WITH 10 -- 기본 값 : 1
MAXVALUE 90 --기본 값은 10의 27승까지
MINVALUE 0 -- 시작 값 이하, 최대값 미만 값, 기본값은 1
NOCYCLE -- 시퀀스 생성값이 MAX 도달할 경우 반복 여부  
CACHE 2; --시퀀스 생성할 번호를 메모리에 미리 할당해 놓은 숫자

INSERT INTO DEPT_SEQUENCE VALUES(SEQ_DEPT_SEQUENCE.NEXTVAL,'DATA', 'SEOUL');
SELECT * FROM DEPT_SEQUENCE;

--현재 시퀀스 값 확인
SELECT SEQ_DEPT_SEQUENCE.CURRVAL FROM DUAL;

ALTER SEQUENCE SEQ_DEPT_SEQUENCE 
INCREMENT BY 3 
MAXVALUE 99
CYCLE;

DROP SEQUENCE SEQ_DEPT_SEQUENCE;


CREATE TABLE TEMP(
COL1 VARCHAR(20), 
COL2 VARCHAR(20));

GRANT SELECT, INSERT ON TEMP TO TEST;


SELECT * FROM TEMP;

--권한 취소
REVOKE INSERT ON TEMP FROM TEST;

--데이터 무결성(제약 조건)
--NOT NULL
CREATE TABLE TABLE_NOTNULL(
LOGIN_ID VARCHAR(20) NOT NULL,
LOGIN_PWD VARCHAR2(20) NOT NULL,
TEL VARCHAR2(20)
);

--Cannot insert NULL into ("SCOTT"."TABLE_NOTNULL"."LOGIN_PWD")
INSERT INTO TABLE_NOTNULL(LOGIN_ID, LOGIN_PWD,TEL)
VALUES('TEST_ID01','TEST_PWD01',NULL);

INSERT INTO TABLE_NOTNULL(LOGIN_ID, LOGIN_PWD)
VALUES('TEST_ID02','TEST_PWD02');


SELECT * FROM TABLE_NOTNULL;

--제약조건 확인

SELECT * FROM USER_CONSTRAINTS;


--제약 조건 시 이름 지정
CREATE TABLE TABLE_NOTNULL2(
LOGIN_ID VARCHAR(20) CONSTRAINT TBL_NN2_LOGID_NN NOT NULL,
LOGIN_PWD VARCHAR2(20) CONSTRAINT TBL_NN2_LOGPWD_NN NOT NULL,
TEL VARCHAR2(20)
);

--이미 생성된 테이블에 제약조건 추가
ALTER TABLE TABLE_NOTNULL2 MODIFY(TEL NOT NULL);
--이미 생성된 테이블에 제약조건 추가 (제약조건명 포함)
ALTER TABLE TABLE_NOTNULL2 MODIFY(TEL CONSTRAINT TBL_NN2_TEL_NN NOT NULL);
--이미 생성된 제약 조건명 변경하기
ALTER TABLE TABLE_NOTNULL2 RENAME CONSTRAINT SYS_C007034 TO TBL_NN2_TEL_NN; 
--제약 조건 삭제
ALTER TABLE TABLE_NOTNULL2 DROP CONSTRAINT TBL_NN2_TEL_NN;

DESC TABLE_NOTNULL2;


--UNIQUE : 저장할 데이터의 중복 안됨
CREATE TABLE TABLE_UNIQUE(
    LOGIN_ID VARCHAR(20) UNIQUE,
    LOGIN_PWD VARCHAR2(30) NOT NULL,
    TEL VARCHAR(20)
    );
    
INSERT INTO TABLE_UNIQUE(LOGIN_ID,LOGIN_PWD,TEL)
VALUES('hong123','hong123','010-1234-1234');
--unique constraint
INSERT INTO TABLE_UNIQUE(LOGIN_ID,LOGIN_PWD,TEL)
VALUES('hong123','hong123','010-1234-1234');

CREATE TABLE TABLE_UNIQUE(
    LOGIN_ID VARCHAR(20) CONSTRAINT TBL_UNQ_LGNID_UNQ UNIQUE,
    LOGIN_PWD VARCHAR2(30) CONSTRAINT TBL_UNQ_LGNPwD_UNQ NOT NULL,
    TEL VARCHAR(20)
    );
    
    
--PRIMARY KEY(기본키) : 유일하게 하나만 있는 값

CREATE TABLE TABLE_PK( 
  LOGIN_ID VARCHAR(20) PRIMARY KEY, --NOT NULL+UNIQUE
  LOGIN_PWD VARCHAR(20) NOT NULL,
  TEL VARCHAR2(20));
  
DESC TABLE_PK;


INSERT INTO TABLE_PK(LOGIN_ID,LOGIN_PWD,TEL)
VALUES('hong123','hong123','010-1234-1234');
--unique constraint
INSERT INTO TABLE_PK(LOGIN_ID,LOGIN_PWD,TEL)
VALUES('hong123','hong123','010-1234-1234');

--이름 지정
CREATE TABLE TABLE_PK2( 
  LOGIN_ID VARCHAR(20) CONSTRAINT TBL_PK2_LOGID_PK PRIMARY KEY, --NOT NULL+UNIQUE
  LOGIN_PWD VARCHAR(20) CONSTRAINT TBL_PK2_LOGPWD_PK NOT NULL,
  TEL VARCHAR2(20));
  

--제약 조건 모아서 주기(NOT NULL은 제외)
CREATE TABLE TABLE_CONSTRAINT( 
ID NUMBER(4),
NAME VARCHAR2(10),
ADDR VARCHAR2(20),
TEL VARCHAR2(20),
CONSTRAINT TBL_ID_PK PRIMARY KEY(ID),
CONSTRAINT TBL_TEL_UNQ UNIQUE(TEL));


--외래키 : FOREIGN KEY(FK) 테이블 간의 관계 설정
--ntegrity constraint (SCOTT.FK_DEPTNO) violated - parent key not found
--EMP 테이블의 DEPTNO 값은 DEPT 테이블의 DEPTNO가 가지고 있는 값 범위 내에서만 가능
SELECT * FROM EMP;
INSERT INTO EMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) 
VALUES(9999,'홍길동','CLERK','7788',SYSDATE,1200,NULL,50);


CREATE TABLE DEPT_FK(
   DEPTNO NUMBER(2) CONSTRAINT DEPT_FK_DEPTNO_PK PRIMARY KEY,
   DANME VARCHAR2(14),
   LOC VARCHAR2(13));
   
SELECT * FROM DEPT_FK;

CREATE TABLE EMP_FK(
     EMPNO NUMBER(4) CONSTRAINT EMPFK_EMPNO PRIMARY KEY,
     ENAME VARCHAR2(10),
     JOB VARCHAR2(9),
     MGR NUMBER(4),
     HIREDATE DATE,
     SAL NUMBER(7,2),
     COMM NUMBER(7,2),
     DEPTNO NUMBER(2) CONSTRAINT EMPFK_DEPTNO_FK REFERENCES DEPT_FK(DEPTNO));

--외래 키 지정시 부모 테이블에 먼저 데이터 입력
INSERT INTO DEPT_FK VALUES(50,'DATABASE','SEOUL');

INSERT INTO EMP_FK(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
VALUES(9999,'홍길동','CLERK','7788',SYSDATE,1200,NULL,50);

--외래 키 지정시 데이터를 삭제한다면 참조하는 자식 테이블의 데이터를 먼저 삭제
--CONSTRAINT (SCOTT.EMPFK DEPTNO_FK VIOLATED -CHILD RECORD FOUND)
DELETE FROM EMP_FK WHERE EMPNO=9999;
DELETE FROM DEPT_FK WHERE DEPTNO=50;

DROP TABLE EMP_FK;

--데이터 삭제 시 참조하는 데이터도 같이 삭제
CREATE TABLE EMP_FK(
    EMPNO NUMBER(4) CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9),
    MGR NUMBER(4),
    HIREDATE DATE,
    SAL NUMBER(7,2), 
    COMM NUMBER(7,2),
    DEPTNO NUMBER(2) CONSTRAINT EMPFK_DEPTNO_FK REFERENCES DEPT_FK(DEPTNO)
    ON DELETE CASCADE --참조하는 데이터 같이 삭제
    );   
--ON DELETE SET NULL 참조하는 데이터를 NULL로 수정

--DEFAULT : 기본값 지정
CREATE TABLE TABLE_DEFAULT(
LOGIN_ID VARCHAR2(20) CONSTRAINT TBLCK2_LOGINID_PK PRIMARY KEY,
LOGIN_PWD VARCHAR2(20) DEFAULT '1234',
TEL VARCHAR(20)
);

INSERT INTO TABLE_DEFAULT(LOGIN_ID, TEL) VALUES('TEST','010-1234-1234');
SELECT * FROM TABLE_DEFAULT;



--Q) DEPT_CONST 테이블 작성하기
--열 이름 DEPTNO 정수형 숫자(2), PRIMARY KEY, 제약 조건명 : DEPTCONST_DEPTNO_PK
--열 이름 DEPTNAME 가변형 문자열(14), UNIQUE, 제약 조건명 : DEPTCONST_DEPTNAME_UNIQ
--열 이름 LOC 가변형 문자열(13), NOT NULL, 제약 조건명 : DEPTCONST_LOC_NN

CREATE TABLE DEPT_CONST (
 
DEPTNO NUMBER(2) CONSTRAINT DEPTCONST_DEPTNO_PK PRIMARY KEY,
DEPTNAME VARCHAR2(14) CONSTRAINT DEPTCONST_DEPTNAME_UNIQ UNIQUE,
LOC VARCHAR2(13) CONSTRAINT DEPTCONST_LOC_NN NOT NULL );

--Q) EMP_CONST 테이블 작성하기
--EMPNO 정수형 숫자(4) PRIMARY KEY, 제약 조건명 ㅣ EMPCONST_EMPNO_PK
--ENAME 가변형 문자열(10) NOT NULL, EMPCONST_ENAME_NN
--JOB 가변형 문자열(9),
--TEL 가변형 문자열(20),UNIQUE, EMPCONST_TEL_UNQ
--HIREDATE 날짜
--SAL 소수점 둘째자리 숫자(7)
--DEPTNO 정수형 숫자(2) FOREIGN KEY, EMPCONST_DEPTNO_FK

CREATE TABLE EMP_CONST 
(EMPNO NUMBER(4) CONSTRAINT EMPCONST_EMPNO_PK PRIMARY KEY,
 ENAME VARCHAR2(10) CONSTRAINT EMPCONST_ENAME_NN NOT NULL,
 JOB VARCHAR2(9),
 TEL VARCHAR2(20) CONSTRAINT EMPCONST_TEL_UNQ UNIQUE,
 HIREDATE DATE,
 SAL NUMBER(7,2),
 DEPTNO NUMBER(2) CONSTRAINT EMPCONST_DEPTNO_FK REFERENCES DEPT_CONST(DEPTNO));

--SCOTT 실행
SET SERVEROUTPUT ON;
DECLARE  
 V_DEPT_ROW DEPT%ROWTYPE;
BEGIN 
  SELECT DEPTNO, DNAME, LOC INTO V_DEPT_ROW
  FROM DEPT
  WHERE DEPTNO = 40;
  DBMS_OUTPUT.PUT_LINE('DEPTNO : '|| V_DEPT_ROW.DEPTNO);
  DBMS_OUTPUT.PUT_LINE('DNAME : '|| V_DEPT_ROW.DNAME);
  DBMS_OUTPUT.PUT_LINE('LOC : '|| V_DEPT_ROW.LOC);
END;
/


DECLARE 
  V_NUMBER NUMBER(8) := 13;
BEGIN 
  IF MOD(V_NUMBER,2) = 1 THEN
     DBMS_OUTPUT.PUT_LINE('홀수');
     END IF; 
END;
/


DECLARE 
  V_NUMBER NUMBER(8) := 12;
BEGIN 
  IF MOD(V_NUMBER,2) = 1 THEN
     DBMS_OUTPUT.PUT_LINE('홀수');
  ELSIF MOD(V_NUMBER,2) =0 THEN
     DBMS_OUTPUT.PUT_LINE('짝수'); 
  END IF;
END;
/

DECLARE 
  V_NUMBER NUMBER := 87;
BEGIN 
  IF V_NUMBER >= 90 THEN
    DBMS_OUTPUT.PUT_LINE('A 학점');
   ELSIF V_NUMBER >=80 THEN
      DBMS_OUTPUT.PUT_LINE('B 학점');
   ELSIF V_NUMBER >=70 THEN
      DBMS_OUTPUT.PUT_LINE('C 학점');
    ELSIF V_NUMBER >=60 THEN
       DBMS_OUTPUT.PUT_LINE('D 학점');
  ELSE 
     DBMS_OUTPUT.PUT_LINE('F 학점');
     END IF;
END;
/

--CASE 조건문
DECLARE 
  V_NUMBER NUMBER := 87;
BEGIN 
   CASE TRUNC(V_NUMBER/10) 
   WHEN 10 THEN DBMS_OUTPUT.PUT_LINE('A 학점');
   WHEN 9  THEN DBMS_OUTPUT.PUT_LINE('B 학점');
   WHEN 8 THEN DBMS_OUTPUT.PUT_LINE('C 학점');
   WHEN 7 THEN DBMS_OUTPUT.PUT_LINE('D 학점'); 
       DBMS_OUTPUT.PUT_LINE('F 학점');
 END CASE;
END;
/


--반복문
DECLARE 
 V_NUM NUMBER := 0;
BEGIN 
  FOR i IN 0..4 LOOP
   CONTINUE WHEN MOD(i,2) = 1;
    DBMS_OUTPUT.PUT_LINE('현재 i : '||i);
  END LOOP;
END;
/



--반복문
DECLARE 
 V_NUM NUMBER := 0;
BEGIN 
  FOR i IN 0..4 LOOP
    DBMS_OUTPUT.PUT_LINE('현재 i : '||i);
  END LOOP;
END;
/


DECLARE 
 V_SUM NUMBER := 0;
BEGIN 
  FOR i IN 1..100 LOOP
   V_SUM := V_SUM+i;
   END LOOP;
   DMBS_OUTPUT.PUT_LINE('현재 V_SUM :' || V_SUM);
END;
/

DECLARE
 V_NUM NUMBER := 0;
BEGIN 
  FOR i IN 0..4 LOOP
  CONTINUE WHEN MOD(i,2) = 1;
    DBMS_OUTPUT.PUT_LINE('현재 i : '||i);
  END LOOP;
END;
/


--홀수만 출력
DECLARE
 V_NUM NUMBER := 0;
BEGIN 
  FOR i IN 0..4 LOOP
  CONTINUE WHEN MOD(i,2) = 0;
    DBMS_OUTPUT.PUT_LINE('현재 i : '||i);
  END LOOP;
END;
/
  
--레코드 : DB 하나의 행위, 자료형이 다른 여러 데이터를 저장
DECLARE
  TYPE REC_DEPT IS RECORD( 
    DEPTNO NUMBER(2) NOT NULL:= 99,
    DNAME VARCHAR2(12),
    LOC VARCHAR(20));
    DEPT_rec REC_DEPT;
BEGIN
   --DEPT_rec.DEPTNO := 55;
   DEPT_rec.DNAME := 'DATABASE';
   DEPT_rec.LOC := 'SEOUL';
   DBMS_OUTPUT.PUT_LINE('DEPTNO : ' ||DEPT_rec.DEPTNO);
   DBMS_OUTPUT.PUT_LINE('DNAME : ' ||DEPT_rec.DNAME);
   DBMS_OUTPUT.PUT_LINE('LOC : ' ||DEPT_rec.LOC);
   
END;
/

GRANT SELECT ON DEPT TO JAVADB; 