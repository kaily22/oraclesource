--20번, 50번 부서에서 근무하는 모든 사원들의 LAST_NAME, 부서아이디를 조회

SELECT LAST_NAME, DEPARTMENT_ID FROM EMPLOYEES 
WHERE DEPARTMENT_ID BETWEEN 20 AND 50 
AND SALARY BETWEEN 5000 AND 12000
ORDER BY SALARY;

--연봉이 5000~12000 범위 이외인 사람들의 LAST_NAME, SALARY를 조회
SELECT LAST_NAME, SALARY FROM EMPLOYEES
WHERE SALARY NOT BETWEEN 5000 AND 12000;

--고용일자 

SELECT LAST_NAME, EMPLOYEE_ID, HIRE_DATE FROM EMPLOYEES
WHERE HIRE_DATE BETWEEN '2008-02-20' AND '2008-05-01'
ORDER BY HIRE_DATE DESC;

SELECT LAST_NAME, HIRE_DATE FROM EMPLOYEES
WHERE HIRE_DATE BETWEEN '2004-01-01' AND '2004-12-31'
ORDER BY HIRE_DATE;




--LIKE
--2004년도에 고용된 모든 사람들의 last_name 및 hire_Date 조회하여 입사일 기준으로 오름차순
SELECT LAST_NAME, HIRE_DATE FROM EMPLOYEES
WHERE HIRE_DATE LIKE '04%' 
ORDER BY HIRE_DATE;

--last_name에 u가 포함되는 사원들의 employee_id, last_name을 조회한다.
SELECT EMPLOYEE_ID, LAST_NAME FROM EMPLOYEES
WHERE LAST_NAME LIKE '%u%';


--last_name 네 번째 글자가 a인 사원들의 last_name 조회
SELECT LAST_NAME FROM EMPLOYEES
WHERE LAST_NAME LIKE '___a%';

--last_name 에 a 혹은 e 글자가 있는 사원들의 last_name을 조회하여 last_name으로 오름차순
SELECT LAST_NAME FROM EMPLOYEES
WHERE LAST_NAME LIKE '%a%' OR LAST_NAME LIKE '%e%'
ORDER BY LAST_NAME;

--last_name에 a와 e 글자가 있는 사원들의 last_name을 조회하여 last_name으로 내림차순 
SELECT LAST_NAME FROM EMPLOYEES
WHERE LAST_NAME LIKE '%a%e%' OR LAST_NAME LIKE '%e%a%'
ORDER BY LAST_NAME DESC;

select * from employees;

--IS NULL 

-- 매니저가 없는 사람들의 LAST_NAME, JOB_ID 조회
SELECT LAST_NAME, JOB_ID
FROM EMPLOYEES
WHERE MANAGER_ID IS NULL;

--ST_CLERK인 JOB_ID를 가진 사원이 없는 부서ID 조회 단, 부서번호가 NULL 제외
SELECT DEPARTMENT_ID
FROM EMPLOYEES
WHERE JOB_ID NOT IN ('ST_CLERK') AND DEPARTMENT_ID IS NOT NULL;

--COMMISSION_PCT가 NULL이 아닌 사원들 중에서 COMMISSION = SALARY * COMMISSION_PCT
--를 구하여 EMPLOYEE_ID, FIRST_NAME, JOB_ID 와 함께 출력

SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID , SALARY * COMMISSION_PCT AS COMMISSION
FROM EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL;

--문자열 함수

--FIRST_NAME이 CURTIS인 사람의 FIRST_NAME, LAST_NAME, PHONE_NUMBER, JOB_ID 조회
--단, JOB_ID 결과는 소문자로 출력
SELECT FIRST_NAME, LAST_NAME, PHONE_NUMBER, LOWER(JOB_ID)
FROM EMPLOYEES
WHERE FIRST_NAME = 'Curtis';

--부서번호가 60,70,80,90인 사원들의 EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, JOB_ID 조회
--단, JOB_ID가 IT_PROG인 사원의 경우 프로그래머로 변경해서 출력
SELECT EMPLOYEE_ID,FIRST_NAME, HIRE_dATE,
REPLACE(JOB_ID, 'IT_PROG','Programmer')
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN(60,70,80,90);

-- JOB_ID가 AD_PRES, PU_CLERK인 사원들의 EMPLOYEE_ID, FIRST_NAME, LAST_NAME,
--DEPARTMENT_ID, JOB_ID 조회, 단 사원명은 FIRST_NAME과 LAST_NAME을 연결하여 출력
SELECT EMPLOYEE_ID, (FIRST_NAME || ' ' || LAST_NAME), DEPARTMENT_ID, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID IN('AD_PRES', 'PU_CLERK');


SELECT LAST_NAME, SALARY, CASE WHEN  SALARY BETWEEN 0 AND 1999 THEN SALARY*0
                        WHEN SALARY BETWEEN 0 AND 1999 THEN 0
                        WHEN SALARY BETWEEN 2000 AND 3999 THEN 0.09
                        WHEN SALARY BETWEEN 4000 AND 5999 THEN 0.2
                        WHEN SALARY BETWEEN 6000 AND 7999 THEN 0.3
                        WHEN SALARY BETWEEN 8000 AND 9999 THEN 0.4
                        WHEN SALARY BETWEEN 10000 AND 11999 THEN 0.42
                        WHEN SALARY BETWEEN 12000 AND 13999 THEN 0.44
                        ELSE 0.45
                        END AS TAX_RATE
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 80;

SELECT LAST_NAME, SALARY, DECODE(TRUNC(SALARY/2000,0),
                                 0, 0.00,
                                 1, 0.09,
                                 2, 0.20,
                                 3, 0.30,
                                 4, 0.40,
                                 5, 0.42,
                                 6, 0.44,
                                 0.45) AS TAX_RATE FROM EMPLOYEES 
                                 WHERE DEPARTMENT_ID = 80;
                                
--회사 내의 최대 연봉 및 최소 연봉의 차이 조회

SELECT  MAX(SALARY)-MIN(SALARY) AS SAL_GAP
FROM EMPLOYEES;

--매니저로 근무하는 사원들의 총 수를 조회
SELECT COUNT(DISTINCT MANAGER_ID) AS 매니저 FROM EMPLOYEES;
SELECT * FROM EMPLOYEES;
--부서별 직원의 수를 구하여, 부서번호의 오름차순으로 출력
SELECT DEPARTMENT_ID, COUNT(EMPLOYEE_ID) 
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
ORDER BY DEPARTMENT_ID;

--부서별 급여의 평균 연봉을 출력하기(부서번호, 평균 연봉이 나오도록 하고 부서번호 별 오름차순 조회)
SELECT DEPARTMENT_ID, ROUND(AVG(SALARY))
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
ORDER BY DEPARTMENT_ID;

--동일한 직업을 가진 사원들의 수를 조회
SELECT JOB_ID, COUNT(EMPLOYEE_ID) FROM EMPLOYEES GROUP BY JOB_ID;

--문)
SELECT MIN(SALARY),MANAGER_ID
FROM EMPLOYEES
WHERE MANAGER_ID IS NOT NULL
GROUP BY MANAGER_ID
HAVING MIN(SALARY) >=  6000
ORDER BY MIN(SALARY) DESC;

SELECT * FROM EMPLOYEES;
--JOIN 실습
--문) 자신의 담당 매니저의 고용일보다 빠른 입사자를 찾아 HIRE_DATE, LAST_NAME, MANAGER_ID 출력
-- EMPLOYEES 테이블 SELF JOIN

SELECT E1.HIRE_DATE, E1.LAST_NAME, E1.MANAGER_ID
FROM EMPLOYEES E1, EMPLOYEES E2
WHERE E1.MANAGER_ID = E2.EMPLOYEE_ID
AND E1.HIRE_DATE < E2.HIRE_DATE 
ORDER BY HIRE_DATE, MANAGER_ID;

SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS;
SELECT * FROM LOCATIONS;
--문) 도시 이름이 T로 시작하는 지역에 사는 사원들의 EMPLOYEE_ID, LAST_NAME, DEPARTMENT_ID, 
-- 출력(DEPARTMENTS의 LOCATION_ID와 LOCATIONS의 LOCATION_ID 연결 후 CITY명 알아내기)

SELECT EMPLOYEE_ID, LAST_NAME, E.DEPARTMENT_ID, CITY
FROM EMPLOYEES E JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
    JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
AND CITY LIKE 'T%';

--문) 위치 ID가 1700이고, 사원들의 EMPLOYEE_ID, LAST_NAME, DEPARTMENT_ID, SALARY 조회
-- DEPARTMENTS 테이블과 EMPLOYEES 조인 
SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID, E.SALARY
FROM EMPLOYEES E JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID AND D.LOCATION_ID= 1700;

--문) DEPARTMENT_NAME, LOCATION_ID, 각 부서별 사원 총 수, 각 부서별 평균 연봉 조회하기
-- 평균 연봉은 소수점 2자리까지만 표현

SELECT DEPARTMENT_NAME, LOCATION_ID, COUNT(*), ROUND(AVG(SALARY),2)
FROM EMPLOYEES E , DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID GROUP BY DEPARTMENT_NAME, LOCATION_ID
ORDER BY LOCATION_ID;


--문) EXECUTIVE 부서에 근무하는 모든 사원들의 DEPARTMENT_ID, LAST_NAME, JOB_ID 조회
SELECT E.DEPARTMENT_ID, E.LAST_NAME, E.JOB_ID
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID 
AND D.DEPARTMENT_NAME = 'Executive';


--문) 각 사원 별 소속 부서에서 자신보다 늦게 고용되었으나 많은 연봉을 받는 사원이 존재하는 
--   모든 사원들의 DEPARTMENT_ID, FIRST_NAME, LAST_NAME 조회
-- FIRST_NAME과 LAST_NAME 두 열은 합해서 하나로 출력

SELECT E1.DEPARTMENT_ID, E1.FIRST_NAME|| '' || E1.LAST_NAME AS NAME
FROM EMPLOYEES E1, EMPLOYEES E2
WHERE E1.DEPARTMENT_ID = E2.DEPARTMENT_ID
AND E1.SALARY < E2.SALARY 
AND E1.HIRE_DATE < E2.HIRE_DATE
ORDER BY E1.DEPARTMENT_ID;



--문) LAST_NAME 에 u가 포함되는 사원들과 동일 부서에 근무하는 사원들의 LAST_NAME, EMPLOYEE_ID 조회
SELECT LAST_NAME, EMPLOYEE_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE LAST_NAME LIKE '%u%');

-- EXECUTIVE 부서에 근무하는 모든 사원들의 DEPARTMENT_ID, LAST_NAME, JOB_ID 조회
SELECT  E.DEPARTMENT_ID, LAST_NAME, JOB_ID
FROM EMPLOYEES E
WHERE (E.DEPARTMENT_ID,'Executive') IN ( SELECT DEPARTMENT_ID, DEPARTMENT_NAME FROM DEPARTMENTS);



--문) 소속 부서의 평균 연봉보다 적게 버는 사원들의 LAST_NAME, 평균 연봉, 부서번호, 급여 조회
--부서번호의 내림차순, 급여의 내림차순 정렬 후 출력
--인라인 뷰로 처리(부서번호, 부서별 평균연봉)
SELECT  LAST_NAME, AVG_SAL, E1.DEPARTMENT_ID, E1.SALARY
FROM EMPLOYEES E1,(SELECT ROUND(AVG(SALARY))AS AVG_SAL, DEPARTMENT_ID
                   FROM EMPLOYEES
                   GROUP BY DEPARTMENT_ID) E2
WHERE E1.DEPARTMENT_ID = E2.DEPARTMENT_ID AND E1.SALARY < E2.AVG_SAL
ORDER BY E2.DEPARTMENT_ID DESC, E2.AVG_SAL DESC;

--문) JOB_ID가 'SA_MAN'사원들의 최대 연봉보다 높게 받는 사원들의 LAST_NAME, JOB_ID, SALARY
--조회

SELECT LAST_NAME, JOB_ID, SALARY
FROM EMPLOYEES
WHERE SALARY > (SELECT MAX(SALARY) FROM EMPLOYEES WHERE JOB_ID = 'SA_MAN');


--문) 커미션을 받는 사원들의 부서와 연봉이 동일한 사원들의 LAST_NAME, DEPARTMENT_ID, SALARY 조회
--다중열 서브쿼리로 작성
SELECT * FROM EMPLOYEES;
SELECT LAST_NAME, DEPARTMENT_ID, SALARY
FROM EMPLOYEES 
WHERE (DEPARTMENT_ID, SALARY) IN (SELECT DEPARTMENT_ID, SALARY 
                                  FROM EMPLOYEES 
                                  WHERE COMMISSION_PCT > 0);

--문) LAST_NAME이 'DAVIES'인 사람보다 나중에 고용된 사원들의 LAST_NAME, HIRE_DATE 조회
SELECT LAST_NAME, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE > (SELECT HIRE_DATE 
                   FROM EMPLOYEES 
                   WHERE LAST_NAME = 'Davies');

--문) LAST_NAME이 'KING'인 사원을 매니저로 두고 있는 모든 사원들의 LAST_NAME, SALARY 조회
SELECT LAST_NAME, SALARY
FROM EMPLOYEES
WHERE MANAGER_ID IN(SELECT EMPLOYEE_ID FROM EMPLOYEES WHERE LAST_NAME = 'King');

--문) LAST_NMAE이 'Zlotkey'인 사원과 동일한 부서에 근무하는 모든 사원들의 employee_id ,hire_date
--    조회
SELECT EMPLOYEE_ID, HIRE_DATE
FROM EMPLOYEES 
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE LAST_NAME = 'Zlotkey');


-- 문) LAST_NAME이 'KOCHHAR'인 사원과 동일한 연봉 및 커미션을 버는 사원들의 LAST_NAME, DEPARTMENT_ID
--SALARY, COMMISSION_PCT 조회. 단, 'KOCHHAR'는 출력결과에서 제외한다.

SELECT E.LAST_NAME, E.DEPARTMENT_ID, E.SALARY, E.COMMISSION_PCT
FROM EMPLOYEES E
WHERE (SALARY, NVL(COMMISSION_PCT,0)) IN ( SELECT SALARY, NVL(COMMISSION_PCT,0)
                                    FROM EMPLOYEES 
                                    WHERE LAST_NAME = 'Kochhar') AND E.LAST_NAME != 'Kochhar';
                                    
